\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{polski}
\usepackage[left=2.5cm,right=2.5cm,top=2cm,bottom=2cm]{geometry}
\usepackage{graphicx}
\linespread{1.3}

\title{\vspace{80mm}Implementacja interfejsu 1wire w VHDL przy użyciu Spartan-3E oraz DS18S20}
\author{Krzysztof Cabała 210047\\ Kinga Wilczek 210063\vspace{110mm}}

\begin{document}
\maketitle
\thispagestyle{empty}

\tableofcontents
\newpage
\listoffigures

\newpage

\section{Założenia projektowe}

Celem projektu było przygotowanie układu obsługującego sensor Dallas DS18S20 na platformie Xilinx Spartan-3E. W tym celu zaimplementowano obsługę magistrali One wire oraz interpretacje wyniku. Efektem działania układu jest wyświetlona wartość temperatury na wyświetlaczu LCD zgodnym ze standardem HD44780.

\section{Wstęp teoretyczny}
\subsection{Interfejs}
Interfejs 1wire jest interfejsem opracowanym przez firmę Dallas Semiconductor do komunikacji między dwoma lub większą liczbą urządzeń przy wykorzystaniu zaledwie jednej lini danych, linii GND (konieczne odniesienie dla poprawnego rozpoznawania stanów logicznych) oraz zasialania Vcc. 
W ramach oszczędności przewodów ogranicza się połączenia do dwóch lini, wtedy układ zasilany jest pasożytniczo z lini danych.
Przykładowe połacznie przedstawia schemat:

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{graphics/idea.png}
\end{center}
\caption{Przykładowe połączenie urządzeń}
\label{schemonewire}
\end{figure}

Wyróżnia się urządzania typu Master (najczęsciej mikrokontroler) oraz Slave (peryferia).

\subsection{Komunikacja}

\subsubsection{Inicjalizacja i reset}

Każda próba komunikacji urządzeń master i slave musi zacząć się od sekwencji składającej się z sygnału reset, wysyłanego przez master, po którym następuje sygnał obecności układu slave. Sygnał reset to wymuszony stan 0 trwający przynajmniej 480$\mu$s. Następnie master oczekuje na sygnał obecności innego urządzenia na linii. Następuje wówczas zwolnienie magistrali, co powoduje podciągnięcie jej do stanu wysokiego przez rezystor pull-up. Urządzenie slave wykrywa wówczas narastające zbocze lini i po upływie 15$\mu$s-60$\mu$s sygnalizuje swoją obecność poprzez wymuszenie stanu niskiego na okres 60$\mu$s-240$\mu$s.

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.4]{graphics/init.png}
\end{center}
\caption{Diagram czasowy dla procedury inicjalizacji}
\label{inititming}
\end{figure}

\subsubsection{Zapis bitu}
Operacje zapisu bitu realizowane są w ściśle określonych slotach czasowych. Długość jednego slotu wynosić zwykle 60$\mu$s. Próbkowanie dokonywane jest mniej więcej w środku slotu celem uodpornienia na błędy. Pomiędzy kolejnymi operacjami wymagana jest przynajmniej 1$\mu$s odstępu.

Zapis rozpoczyna się wysterowaniem linii danych przez master na poziom niski. Zapis 0 wymaga utrzymania jej w tym stanie przez cały slot. Zapis 1 jest nieco bardziej skomplikowany. Master musi w czasie nie dłuższym niż 15$\mu$s, ale nie krótszym niż 1$\mu$s zwolnić magistralęm tak aby w momencie próbkowania (po 30$\mu$s od zbocza opadającego) była w stanie wysokim. 

\subsubsection{Odczyt bitu}
Odczyt bitu również wymaga 60$\mu$s slotu oraz 1$\mu$s przerwy. Odczyt rozpoczyna się wymuszeniem przez master stanu niskiego na linii danych na czas nie krótszy niż 1$\mu$s i zwolnienie jej (powrót do stanu wysokiego). Po tym sygnale sterowanie linią przejmuje urządzenie slave, wysyłające bit 0 lub 1. Slave po wykryciu zbocza opadającego wymusza stan niski (dla 0) lub utrzymuje  wysoki (dla 1) linii danych. Sygnał musi być wtedy spróbkowany przez master. Przed upłynięciem czasu końca slotu maigistrala zostaje zwolniona przez slave, co powoduje jej powrót do stanu wysokiego.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=14cm]{graphics/slots.png}
\end{center}
\caption{Diagramy czasowe dla procedury zapisu i odczytu}
\label{slotsitming}
\end{figure}

\subsection{Konwersja i odczyt temperatury}
Aktualny odczyt temperatury zapisany jest w dwóch pierwszych bajtach pamięci Scratchpad. Po poprawnej inicjalizacji czujnika DS18S20 ich zawartość odpowiada temperaturze +85$^\circ$C. W celu zmierzenia aktualnej temperatury należy wysłać do termometru komendę konwersji, zresetować układ i odczytać pamięć.

\subsection{Double dabble}
Double dabble jest powszechnie wykorzystywanym algorytmem do konwersji liczb binarnych na kod BCD (Binary-Coded Decimal - system dziesiętny zakodowany dwójkowo). 

Algorytm polega na wykonaniu n iteracji (w zależności od długości ciągu bitów). Początkowo wynikowy kod BCD jest zainicjalizowany jako ciąg zer podzielonych na grupy po 4 bity. Podczas każdej iteracji wykonywane jest przesunięcie o jeden bit w lewo, a na koniec doklejany jest jeden bit ciągu wejściowego. Jeżeli przed kolejnym przesunięciem wartość w jednej z grup w kodzie BCD jest wyższa niż 4 to następuje dodanie binarnej 3. Po wykonaniu odpowiedniej ilości iteracji algorytm kończy swoje działanie. Ostatecznie wynikowy ciąg jest podzielony po cztery bity, które odpowiadają kolejnym cyfrom wyniku. 

\section{Implementacja}

\subsection{Schemat główny}

Funkcjonalność projektu opiera się na 6 podstawowych modułach widocznych na rysunku \ref{top_level}:
\begin{itemize}
\item Termometer - obsługa sensora DS18S20;
\item RotaryEnc- sterowanie częstotliwością pomiaru;
\item Interpreter - interpretacja 2 bajtowego wyniku;
\item double\_dabble - zamiana liczby binarnej bez znaku na kod BCD;
\item LCD - generowanie zawartości wyświetlacza LCD;
\item LCDWrite - sterownik wyświetlacza.
\end{itemize}

\begin{figure}[!h]
\begin{center}
\includegraphics{graphics/top_level.png}
\end{center}
\caption{Schemat ogólny projektu}
\label{top_level}
\end{figure}

\subsection{Termometer}
Moduł Termometer jest najbardziej rozbudowanym modułem składającym się z 4 układów (rysunek \ref{termometer}):
\begin{itemize}
\item Controller - obsługa sekwencji komunikacji i konwersji temperatury;
\item ByteModule - obsługa komunikacji na poziomie bajtu (instrukcji);
\item BusController - obsługa magistrali Onewire;
\item IOBuf - ustala kierunek komunikacji.
\end{itemize}

\begin{figure}[!h]
\begin{center}
\includegraphics[height=20cm]{graphics/termometer.png}
\end{center}
\caption{Moduł Termometer}
\label{termometer}
\end{figure}

\newpage
========================================================================

\section{Implementacja podstawowych operacji}

Za realizację podstawowych operacji odpowiada moduł BusController. 

\begin{figure}[!h]
\begin{center}
\includegraphics[height=5cm]{graphics/bus_controller_sym.png}
\end{center}
\caption{Moduł obsługi podstawowych operacji bitowych}
\label{bus_controller_sym}
\end{figure}

Poniżej przedstawiono schemat blokowy tego automatu.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=15cm]{graphics/bus_controller_fsm.png}
\end{center}
\caption{Maszyna stanów BusController}
\label{bus_controller_fsm}
\end{figure}

Poprawna obsługa magistrali wymaga jej zwalniania poprzez ustawienie w stan wysokiej impedancji (podciągnięcie do Vcc przez rezystor pull-up). Służy do tego element IOBuf. Podanie logicznego zera na wejście T otwiera bufor wyjściowy i przekazuje sygnał podawany na pin I (GND - Logiczne 0). Logiczne 1 na wejściu T ustawia linie w stanie wysokiej impednacji (zwalnia magistralę). Pin O służy do odczytu stanu magistrali.

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=1.4]{graphics/io_buf_sym.png}
\end{center}
\caption{Symbol IOBuf}
\label{iobuf_controller_sym}
\end{figure}

\section{Transmisja bajtu}

Komunikacja master - slave jest dwukierunkowa. Dane przesyłane są w formie bajtów, kolejność bitów określa zasada najpierw najmłodszy. 

\section{Implementacja transmisji bajtu}

Transmisja bajtu realizowana jest poprzez następny moduł - ByteModule. 

\begin{figure}[h!]
\begin{center}
\includegraphics[height=5cm]{graphics/byte_module_sym.png}
\end{center}
\caption{Moduł transmisji bajtu}
\label{byte_module_sym}
\end{figure}

Automat zawiera po 4 stany na odczyt i zapis oraz jeden stan oczekiwania na sygnał startu.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=15cm]{graphics/byte_module_fsm.png}
\end{center}
\caption{Maszyna stanów ByteModule}
\label{bte_module_fsm}
\end{figure}

\section{Algorytm double dabble}
\section{Implementacja double dabble}
\end{document}