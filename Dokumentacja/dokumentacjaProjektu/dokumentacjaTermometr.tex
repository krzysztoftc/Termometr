\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{polski}
\usepackage[left=2.5cm,right=2.5cm,top=2cm,bottom=2cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\linespread{1.3}

\title{\vspace{80mm}Implementacja interfejsu 1wire w VHDL przy użyciu Spartan-3E oraz DS18S20}
\author{Krzysztof Cabała 210047\\ Kinga Wilczek 210063\vspace{110mm}}

\begin{document}
\maketitle
\thispagestyle{empty}

\tableofcontents
\newpage
\listoffigures

\newpage

\section{Założenia projektowe}

Celem projektu było przygotowanie układu obsługującego sensor Dallas DS18S20 na platformie Xilinx Spartan-3E. W tym celu zaimplementowano obsługę magistrali One wire oraz interpretacje wyniku. Efektem działania układu jest wyświetlona wartość temperatury na wyświetlaczu LCD zgodnym ze standardem HD44780.

\section{Wstęp teoretyczny}
\subsection{Interfejs}
Interfejs 1wire jest interfejsem opracowanym przez firmę Dallas Semiconductor do komunikacji między dwoma lub większą liczbą urządzeń przy wykorzystaniu zaledwie jednej lini danych, linii GND (konieczne odniesienie dla poprawnego rozpoznawania stanów logicznych) oraz zasialania Vcc. 
W ramach oszczędności przewodów ogranicza się połączenia do dwóch lini, wtedy układ zasilany jest pasożytniczo z lini danych.
Przykładowe połacznie przedstawia schemat:

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.3]{graphics/idea.png}
\end{center}
\caption{Przykładowe połączenie urządzeń}
\label{schemonewire}
\end{figure}

Wyróżnia się urządzania typu Master (najczęsciej mikrokontroler) oraz Slave (peryferia).

\subsection{Komunikacja}

\subsubsection{Inicjalizacja i reset}

Każda próba komunikacji urządzeń master i slave musi zacząć się od sekwencji składającej się z sygnału reset, wysyłanego przez master, po którym następuje sygnał obecności układu slave. Sygnał reset to wymuszony stan 0 trwający przynajmniej 480$\mu$s. Następnie master oczekuje na sygnał obecności innego urządzenia na linii. Następuje wówczas zwolnienie magistrali, co powoduje podciągnięcie jej do stanu wysokiego przez rezystor pull-up. Urządzenie slave wykrywa wówczas narastające zbocze lini i po upływie 15$\mu$s-60$\mu$s sygnalizuje swoją obecność poprzez wymuszenie stanu niskiego na okres 60$\mu$s-240$\mu$s.

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=0.4]{graphics/init.png}
\end{center}
\caption{Diagram czasowy dla procedury inicjalizacji}
\label{inititming}
\end{figure}

\subsubsection{Zapis bitu}
Operacje zapisu bitu realizowane są w ściśle określonych slotach czasowych. Długość jednego slotu wynosić zwykle 60$\mu$s. Próbkowanie dokonywane jest mniej więcej w środku slotu celem uodpornienia na błędy. Pomiędzy kolejnymi operacjami wymagana jest przynajmniej 1$\mu$s odstępu.

Zapis rozpoczyna się wysterowaniem linii danych przez master na poziom niski. Zapis 0 wymaga utrzymania jej w tym stanie przez cały slot. Zapis 1 jest nieco bardziej skomplikowany. Master musi w czasie nie dłuższym niż 15$\mu$s, ale nie krótszym niż 1$\mu$s zwolnić magistralęm tak aby w momencie próbkowania (po 30$\mu$s od zbocza opadającego) była w stanie wysokim. 

\subsubsection{Odczyt bitu}
Odczyt bitu również wymaga 60$\mu$s slotu oraz 1$\mu$s przerwy. Odczyt rozpoczyna się wymuszeniem przez master stanu niskiego na linii danych na czas nie krótszy niż 1$\mu$s i zwolnienie jej (powrót do stanu wysokiego). Po tym sygnale sterowanie linią przejmuje urządzenie slave, wysyłające bit 0 lub 1. Slave po wykryciu zbocza opadającego wymusza stan niski (dla 0) lub utrzymuje  wysoki (dla 1) linii danych. Sygnał musi być wtedy spróbkowany przez master. Przed upłynięciem czasu końca slotu maigistrala zostaje zwolniona przez slave, co powoduje jej powrót do stanu wysokiego.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=14cm]{graphics/slots.png}
\end{center}
\caption{Diagramy czasowe dla procedury zapisu i odczytu}
\label{slotsitming}
\end{figure}

\subsection{Konwersja i odczyt temperatury}
Aktualny odczyt temperatury zapisany jest w dwóch pierwszych bajtach pamięci Scratchpad. Po poprawnej inicjalizacji czujnika DS18S20 ich zawartość odpowiada temperaturze +85$^\circ$C. W celu zmierzenia aktualnej temperatury należy wysłać do termometru komendę konwersji, zresetować układ i odczytać pamięć. W pamięci urządzenia jest 9 bajtów wyniku. Tylko dwa pierwsze są istotne w punktu wyniku. Pierwszy uzyskany bajt określa znak odczytu. Natomiast ostatni bit drugiego bajtu stanowi o wystąpieniu cyfry po przecinku. Pozostałe bity wyniku to wartość odczytanej temperatury.  Wartość ta następnie podlega konwersji na kod BCD za pomocą  algorytmu double dabble.

\subsection{Double dabble}
Double dabble jest powszechnie wykorzystywanym algorytmem do konwersji liczb binarnych na kod BCD (Binary-Coded Decimal - system dziesiętny zakodowany dwójkowo). 

Algorytm polega na wykonaniu n iteracji (w zależności od długości ciągu bitów). Początkowo wynikowy kod BCD jest zainicjalizowany jako ciąg zer podzielonych na grupy po 4 bity. Podczas każdej iteracji wykonywane jest przesunięcie o jeden bit w lewo, a na koniec doklejany jest jeden bit ciągu wejściowego. Jeżeli przed kolejnym przesunięciem wartość w jednej z grup w kodzie BCD jest wyższa niż 4 to następuje dodanie binarnej 3. Po wykonaniu odpowiedniej ilości iteracji algorytm kończy swoje działanie. Ostatecznie wynikowy ciąg jest podzielony po cztery bity, które odpowiadają kolejnym cyfrom wyniku. 

\section{Implementacja}

\subsection{Schemat główny}

Funkcjonalność projektu opiera się na 6 podstawowych modułach widocznych na rysunku \ref{top_level}:
\begin{itemize}
\item Termometer - obsługa sensora DS18S20;
\item RotaryEnc- sterowanie częstotliwością pomiaru;
\item Interpreter - interpretacja 2 bajtowego wyniku;
\item double\_dabble - zamiana liczby binarnej bez znaku na kod BCD;
\item LCD - generowanie zawartości wyświetlacza LCD;
\item LCDWrite - sterownik wyświetlacza.
\end{itemize}

\begin{figure}[!h]
\begin{center}
\includegraphics{graphics/top_level.png}
\end{center}
\caption{Schemat ogólny projektu}
\label{top_level}
\end{figure}

\subsection{Termometer}
Moduł Termometer jest najbardziej rozbudowanym modułem składającym się z 4 układów (rysunek \ref{termometer}):
\begin{itemize}
\item Controller - obsługa sekwencji komunikacji i konwersji temperatury;
\item ByteModule - obsługa komunikacji na poziomie bajtu (instrukcji);
\item BusController - obsługa magistrali Onewire;
\item IOBuf - ustala kierunek komunikacji.
\end{itemize}

\begin{figure}[!h]
\begin{center}
\includegraphics[height=20cm]{graphics/termometer.png}
\end{center}
\caption{Moduł Termometer}
\label{termometer}
\end{figure}

\subsubsection{Controller}


Moduł Controller (rysunek \ref{controller_sym}) odpowiada za przeprowadzenie poprawnej sekwencji operacji wymaganych do zmierzenia i odczytu temperatury.

\begin{figure}[!h]
\begin{center}
\includegraphics[height=5cm]{graphics/controller_sym.png}
\end{center}
\caption{Moduł Controller}
\label{controller_sym}
\end{figure}

Opis wyprowadzeń:

Wejścia
\begin{itemize}
\item CLK - Zegar;
\item Freq\_up - Impuls zwiększenia częstotliwości próbkowania;
\item Freq\_down - Impul zmniejszenia częstotliwości próbkowania;
\item Byte\_in - Bajt odebrany przez ByteModule;
\item Bit\_in - Bit odeberany przez BusController;
\item Busy\_in - Flaga zajętości ByteModule;
\item c\_Busy\_in - Flaga zajętości BusController;
\end{itemize}

Wyjścia:
\begin{itemize}
\item Start - Sygnał start dla ByteControllera;
\item Data\_out - Odebrany ciag reprezentujący temperaturę (2 bajty);
\item Byte\_out - Dane (kod instrukcji) dla ByteContorllera;
\item Reser - Sygnał reset;
\item Freq\_state - Wektor reprezentujący aktualną częstotliwość próbkowania;
\item Reset\_start - Sygnał start dla BusControllera. 
\end{itemize}

W celu ogaraniczenia częstotliwości odczytu (co powoduje nadmierne nagrzewanie się czujnika) dodano możliwość sterowania odstępem między pomiarami. Moduł umożliwia odczyt 4, 2, 1 sekundę lub ciągły. Zmiana odbywa się w procesie freq\_process.

\lstset{language=VHDL}
\begin{lstlisting}[frame=single]
freq_process: process (CLK, freq_up, freq_down)
begin
	if rising_edge(clk) then
		if freq_up = '1' then
			frequence <= frequence(2 downto 0) & frequence (3);
		elsif freq_down = '1' then
			frequence <= frequence (0) & frequence(3 downto 1);

		end if;
	end if;
end process;
\end{lstlisting}

Moduł jest automatem skończonym (fsm). Zmiana stanów odbywa się w procesie  state\_service.

\lstset{language=VHDL}
\begin{lstlisting}[frame=single]
state_service: process (CLK, next_state)
begin
	if (rising_edge (CLK)) then
		state <= next_state;
	end if;
end process;
\end{lstlisting}

Kolejne stany maszyny pokazuje Rysunek \ref{controller_fsm}. Po każdym ze stanów (poza presence) występuje dodatkowy stan oczekiwania na zwolnienie flagi busy (zajętości kontrolerów niższego rzędu). Stany te zostały pominięte na schemacie ze względu na jego czytelność. Należy zaznaczyć, że stany w których wykonwywane są kolejne komendy są jednotaktowe, podczas gdy oczekiwanie na ich wykonanie zajmuje stosunkowo dużo więcej czasu. Zauważyć to można na symulacji pokazanej na rysunku \ref{controller_sym}

\begin{figure}[!h]
\begin{center}
\includegraphics[height=10cm]{graphics/controller_fsm.png}
\end{center}
\caption{Maszyna stanów Controller}
\label{controller_fsm}
\end{figure}

\begin{figure}[!h]
\begin{center}
\includegraphics[height=24cm]{graphics/controller_symulation.png}
\end{center}
\caption{Symulacja automatu Controller}
\label{controller_sym}
\end{figure}

Zaznaczona na symulacji pozyjca A pokazuje moment zwolenia magistrali przez master (stan wysokiej impedancji). Zaraz po jej zwolnieniu kontrolę przejmuje slave, który wymuszając stan niski sygnalizuje swoją obecność (moment B). Przybliżony fragment (czerwona ramka) obrazuje przejścia stanów pomiędzy reset\_slave\_b a skip\_b. Widać, że stany presence oraz skip są jednotaktowe. 

\newpage
========================================================================

\section{Implementacja podstawowych operacji}

Za realizację podstawowych operacji odpowiada moduł BusController. 

\begin{figure}[!h]
\begin{center}
\includegraphics[height=5cm]{graphics/bus_controller_sym.png}
\end{center}
\caption{Moduł obsługi podstawowych operacji bitowych}
\label{bus_controller_sym}
\end{figure}

Poniżej przedstawiono schemat blokowy tego automatu.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=15cm]{graphics/bus_controller_fsm.png}
\end{center}
\caption{Maszyna stanów BusController}
\label{bus_controller_fsm}
\end{figure}

Poprawna obsługa magistrali wymaga jej zwalniania poprzez ustawienie w stan wysokiej impedancji (podciągnięcie do Vcc przez rezystor pull-up). Służy do tego element IOBuf. Podanie logicznego zera na wejście T otwiera bufor wyjściowy i przekazuje sygnał podawany na pin I (GND - Logiczne 0). Logiczne 1 na wejściu T ustawia linie w stanie wysokiej impednacji (zwalnia magistralę). Pin O służy do odczytu stanu magistrali.

\begin{figure}[!h]
\begin{center}
\includegraphics[scale=1.4]{graphics/io_buf_sym.png}
\end{center}
\caption{Symbol IOBuf}
\label{iobuf_controller_sym}
\end{figure}

\section{Transmisja bajtu}

Komunikacja master - slave jest dwukierunkowa. Dane przesyłane są w formie bajtów, kolejność bitów określa zasada najpierw najmłodszy. 

\section{Implementacja transmisji bajtu}

Transmisja bajtu realizowana jest poprzez następny moduł - ByteModule. 

\begin{figure}[h!]
\begin{center}
\includegraphics[height=5cm]{graphics/byte_module_sym.png}
\end{center}
\caption{Moduł transmisji bajtu}
\label{byte_module_sym}
\end{figure}

Automat zawiera po 4 stany na odczyt i zapis oraz jeden stan oczekiwania na sygnał startu.

\begin{figure}[!h]
\begin{center}
\includegraphics[width=15cm]{graphics/byte_module_fsm.png}
\end{center}
\caption{Maszyna stanów ByteModule}
\label{bte_module_fsm}
\end{figure}

\section{Algorytm double dabble}
\section{Implementacja double dabble}
\end{document}